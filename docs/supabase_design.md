# Supabase Backend Design

## Goals
- Menyediakan fondasi backend real-time untuk percakapan, transaksi keuangan, dan kolaborasi multi-user.
- Memungkinkan integrasi pipeline LLM untuk ekstraksi transaksi dari chat/dokumen.
- Menjaga keamanan data dengan row level security (RLS) dan audit trails.

## Schema Overview
```
profiles (user metadata)
conversations ─┐
conversation_participants ├─< messages ─┐
                                   │     └─ transaction_items
                                   └─ transactions
categories ─┴───────────────┐
llm_jobs (async pipeline)   ├─ documents (attachments, OCR)
sync_states (per device)    └─ message_events (delivery/read receipt)
```

### Table Definitions (Supabase SQL)
```sql
create table public.profiles (
  id uuid primary key references auth.users on delete cascade,
  display_name text,
  avatar_url text,
  preferred_currency text default 'IDR',
  locale text default 'id-ID',
  created_at timestamptz default now()
);

create table public.conversations (
  id uuid primary key default gen_random_uuid(),
  title text,
  owner_id uuid not null references public.profiles(id) on delete cascade,
  type text not null check (type in ('personal','household','business')),
  llm_preset text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table public.conversation_participants (
  conversation_id uuid references public.conversations(id) on delete cascade,
  user_id uuid references public.profiles(id) on delete cascade,
  role text not null check (role in ('owner','editor','viewer')),
  status text default 'active' check (status in ('active','invited','left')),
  joined_at timestamptz default now(),
  primary key (conversation_id, user_id)
);

create table public.messages (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  author_id uuid not null references public.profiles(id) on delete set null,
  text text,
  metadata jsonb default '{}',
  status text default 'sent' check (status in ('sent','delivered','read','failed')),
  created_at timestamptz default now()
);

create table public.message_events (
  id bigint generated by default as identity primary key,
  message_id uuid not null references public.messages(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  event_type text check (event_type in ('delivered','read')),
  event_ts timestamptz default now()
);

create table public.categories (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid references public.conversations(id) on delete cascade,
  name text not null,
  type text not null check (type in ('income','expense','saving','investment')),
  keywords text,
  icon text,
  is_builtin boolean default false,
  created_at timestamptz default now()
);

create table public.transactions (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  message_id uuid references public.messages(id) on delete set null,
  owner_id uuid references public.profiles(id) on delete set null,
  kind text not null check (kind in (
    'income','expense','saving_in','saving_out','investment_in','investment_out','transfer'
  )),
  amount numeric(18,2) not null,
  currency text not null default 'IDR',
  category_id uuid references public.categories(id) on delete set null,
  description text,
  occurred_at timestamptz default now(),
  created_at timestamptz default now(),
  source text default 'chat',
  confidence numeric(5,2) default 1.0
);

create table public.transaction_items (
  id uuid primary key default gen_random_uuid(),
  transaction_id uuid not null references public.transactions(id) on delete cascade,
  label text,
  amount numeric(18,2)
);

create table public.documents (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  uploader_id uuid references public.profiles(id) on delete set null,
  message_id uuid references public.messages(id) on delete set null,
  file_url text not null,
  mime_type text,
  extracted_text text,
  llm_payload jsonb,
  status text default 'processing' check (status in ('processing','ready','failed')),
  created_at timestamptz default now()
);

create table public.llm_jobs (
  id bigint generated by default as identity primary key,
  conversation_id uuid not null,
  message_id uuid,
  document_id uuid,
  job_type text not null check (job_type in ('parse_chat','parse_document','reconcile')),
  payload jsonb not null,
  status text default 'queued' check (status in ('queued','running','error','done')),
  error text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table public.sync_states (
  device_id uuid,
  user_id uuid references public.profiles(id) on delete cascade,
  conversation_id uuid references public.conversations(id) on delete cascade,
  last_message_at timestamptz,
  checkpoint jsonb,
  primary key (device_id, conversation_id)
);

create table public.audit_log (
  id bigint generated by default as identity primary key,
  user_id uuid,
  action text,
  entity text,
  entity_id uuid,
  data jsonb,
  created_at timestamptz default now()
);
```

### Index Suggestions
```sql
create index on public.messages (conversation_id, created_at desc);
create index on public.transactions (conversation_id, occurred_at desc);
create index on public.documents (conversation_id, created_at desc);
create index on public.llm_jobs (status, created_at);
```

## Row Level Security Policies
Aktifkan RLS:
```sql
alter table public.conversations enable row level security;
alter table public.conversation_participants enable row level security;
alter table public.messages enable row level security;
alter table public.transactions enable row level security;
alter table public.categories enable row level security;
alter table public.documents enable row level security;
alter table public.sync_states enable row level security;
```

Contoh kebijakan:
```sql
create policy "conversation access" on public.conversations
  for select using (
    auth.uid() = owner_id or
    auth.uid() in (
      select user_id from public.conversation_participants cp
      where cp.conversation_id = conversations.id and cp.status = 'active'
    )
  );

create policy "manage owned conversations" on public.conversations
  for all using (auth.uid() = owner_id);

create policy "participating messages" on public.messages
  for select using (
    auth.uid() in (
      select user_id from public.conversation_participants cp
      where cp.conversation_id = messages.conversation_id and cp.status = 'active'
    )
  );

create policy "author can insert" on public.messages
  for insert with check (
    auth.uid() = author_id and
    auth.uid() in (
      select user_id from public.conversation_participants cp
      where cp.conversation_id = messages.conversation_id and cp.status = 'active'
    )
  );

create policy "editors write transactions" on public.transactions
  for insert with check (
    auth.uid() in (
      select user_id from public.conversation_participants cp
      where cp.conversation_id = transactions.conversation_id
        and cp.role in ('owner','editor')
        and cp.status = 'active'
    )
  );

create policy "read transactions" on public.transactions
  for select using (
    auth.uid() in (
      select user_id from public.conversation_participants cp
      where cp.conversation_id = transactions.conversation_id and cp.status = 'active'
    )
  );

create policy "category visibility" on public.categories
  for select using (
    conversation_id is null or
    auth.uid() in (
      select user_id from public.conversation_participants cp
      where cp.conversation_id = categories.conversation_id and cp.status = 'active'
    )
  );
```
Tambahkan policy serupa untuk `documents`, `conversation_participants`, dan `sync_states` agar hanya pemilik data yang dapat mengubah checkpoint device-nya.

## Edge Functions Outline
- `submit_message` (POST): validasi partisipasi, simpan pesan, optional enqueue `llm_jobs`. Balikan payload message + status.
- `create_invite` (POST owner/editor): buat kode undangan (UUID + expiry). Simpan di tabel `conversation_invites` (tambahan) dan kirim link.
- `accept_invite` (POST): verifikasi kode, masukkan user ke `conversation_participants`, set status `active`, hapus/habis masa berlaku.
- `record_event` (POST): update delivery/read receipt (opsional, bisa langsung dari client via REST).

Edge Function baseline:
```ts
import { serve } from "https://deno.land/std/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js";

serve(async (req) => {
  const supabase = createClient(Deno.env.get("SUPABASE_URL")!, Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!);
  const auth = req.headers.get("Authorization");
  // parse JWT, validate user, perform action...
});
```

## LLM Worker Pipeline
1. Trigger: pesan baru atau dokumen diunggah → `submit_message` menambah record di `llm_jobs`.
2. Worker (FastAPI/Node) melakukan polling atau memakai Supabase Realtime dengan service key.
3. Pipeline:
   - Preprocess teks (normalisasi angka/currency, deteksi bahasa).
   - Jalankan parser rule-based (fastText + regex) untuk ekstraksi cepat.
   - Jika confidence rendah atau banyak entitas, panggil LLM (mis. GPT-4o mini / Llama 3) dengan prompt JSON schema.
   - Validasi bisnis (saldo tidak negatif, kategori valid, double-entry bila perlu).
   - Simpan hasil ke `transactions`, buat pesan sistem balasan (`messages` dengan `metadata` detail parsed).
   - Update status `llm_jobs` ke `done` atau `error` + log ke `audit_log`.

## Flutter Integration Checklist
- Gunakan `supabase_flutter` untuk Auth/realtime. Simpan session lokal untuk offline.
- Buat repository per domain: auth, conversation, messages, transactions.
- Observasi real-time: `supabase.channel('messages:conversation_id=eq.<id>')` → update state provider.
- Offline-first: sinkronkan server → `sqflite` lokal, simpan `sync_states.last_message_at` untuk incremental fetch (`created_at > checkpoint`).
- Pengiriman pesan: insert ke `messages` (optimistic update) → panggil Edge Function untuk verifikasi + job scheduling.
- Undangan: terima deep link → Edge Function `accept_invite` → refresh conversation list.
- Manajemen kategori: fetch global (conversation_id null) + custom, simpan lokal, sinkronkan kata kunci ke fastText dataset.

## Next Steps
1. Port SQL di atas ke migrasi Supabase CLI (`supabase migration new`).
2. Tambahkan tabel `conversation_invites` dan `conversation_tokens` bila diperlukan.
3. Implementasi Edge Functions dengan validasi JWT + penggunaan service-role key hanya di server.
4. Setup worker (Railway/Render) untuk memproses `llm_jobs`.
5. Integrasikan Flutter: auth → list conversation → chat UI real-time → transaksi view.
6. Susun test plan (unit + integration) untuk memastikan RLS dan pipeline bekerja.
